---
title: Mysql索引使用规则？索引查询失效的情况？索引缺点以及使用注意？
date: 2021-01-15 15:14:48
tags: [面试, 数据库]
category: [面试, 数据库]
---

```sql
// product表 
create index (shop_id, product_id, gmt_create);
```

# 使用规则

## 全列匹配

where条件正好用到这3个字段，就用到联合索引。

## 最左前缀匹配

SQL里，正好用到联合索引最左边的一个或几个列表。

## 最左前缀匹配，但中间某个值没有匹配

如果sql用了联合索引第一列和第三列，会按照第一列在索引里找，找完后对结果集根据第三列做全表扫描，不会走第三列的索引了。

## 前缀匹配

如果不是等值，或比如=, >, <=等操作，而是Like操作。则只有Like ‘xx%’ (%在最后)这种才能用上索引。

## 范围匹配

只有符号最左前缀的列的范围才用到索引，范围之后的列用不到索引。比如: select * from product where shop_id >= 1 and product_id = 1；这里就只用到shop_id索引。

## 包含函数

对某个列用了函数，则该列不走索引。

# 失效情况

* like以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效；
* or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效；
* 组合索引，不是使用第一列索引，索引失效；
* 数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描；
* 在索引字段上使用not，<>，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。优化方法：key<>0 改为 key>0 or key<0；
* 对索引字段进行计算操作、字段上使用函数；
* 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。

# 缺点

增加磁盘消耗，占用磁盘文件，同时高并发频繁插入和修改索引，会导致性能损耗。

# 使用注意

* 尽量创建少的索引，一个表，两三个；
* 一个字段的值几乎都不太一样的，比如id，这样用索引效果最好。

<span style='color: red;'>互联网系统中，一般尽量降低SQL复杂度，用简单的主键索引(聚簇索引)+少数联合索引，可以覆盖一个表的所有SQL查询，更复杂的业务逻辑，应该放在Java代码里实现。SQL越简单，后面迁移，分库分表，读写分离的成本更低，减少对SQL的改造。MySQL最好用在在线及时存储，不要用于计算(Join, 子查询，函数等等)。高并发场景下，计算放在Java内存里。</span>

